name: company
services:
  pre-install:
      command: 'chroot /host /bin/bash -c "cd ${PWD} && docker plugin install --grant-all-permissions ghcr.io/studioetrange/bindfs:latest || true && docker plugin enable ghcr.io/studioetrange/bindfs:latest || true && exit 0"'
      image: busybox
      container_name: 'pre-install'
      hostname: 'pre-install'
      volumes:
          - '/:/host'
      ipc: host
      pid: host
      network_mode: "host"
      privileged: true
      tty: true
      restart: "no"
      labels:
        - "company.pre-install=true"

  ldap:
    image: lldap/lldap:stable
    container_name: ldap
    networks:
      net1:
        ipv4_address: 172.30.0.49
    volumes:
      - lldap_data:/data
    environment:
      - UID=1000
      - GID=1000
      - TZ=Europe/Berlin
      - LLDAP_JWT_SECRET=Supergeheim # verwende hier einen zufällligen Token. Ist nicht das Passwort.
      - LLDAP_KEY_SEED=Supersupergeheim # verwende hier einen zufällligen Token. Ist nicht das Passwort.
      - LLDAP_LDAP_BASE_DN=dc=company,dc=de
      - LLDAP_LDAP_USER_PASS=Userpasswort1234
    labels:
      - traefik.enable=true
      - traefik.http.routers.lldap.rule=Host(`ldap.docker.localhost`)
      - traefik.http.routers.lldap.entrypoints=websecure
      - traefik.http.services.lldap.loadbalancer.server.port=17170
      - traefik.http.routers.lldap.service=lldap
      - traefik.http.routers.lldap.tls.certresolver=stepca

  woodpecker-server:
    image: woodpeckerci/woodpecker-server:v3
    container_name: woodpecker-server
    hostname: 'woodpecker-server'
    user: root
    #ports:
    #  - 8000:8000
    volumes:
      - woodpecker-server-data:/var/lib/woodpecker/
    environment:
      - WOODPECKER_OPEN=true
      - WOODPECKER_HOST=http://172.30.0.21:8000
      - WOODPECKER_AGENT_SECRET=pssst
      - WOODPECKER_GITEA=true
      - WOODPECKER_GITEA_URL=http://172.30.0.3
      - WOODPECKER_GITEA_CLIENT=YOUR_GITEA_CLIENT
      - WOODPECKER_GITEA_SECRET=YOUR_GITEA_CLIENT_SECRET
    networks:
      net1:
        ipv4_address: 172.30.0.21
    depends_on:
      gitea:
        condition: service_started
      gitea-hc:
        condition: service_healthy
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.woodpecker.rule=Host(`woodpecker.docker.localhost`)"
      - "traefik.http.routers.woodpecker.entrypoints=websecure"
      - "traefik.http.services.woodpecker.loadbalancer.server.port=8000"
      - "traefik.http.routers.woodpecker.tls=true"
      - "traefik.http.routers.woodpecker.tls.certresolver=stepca"
  woodpecker-server-hc:
      image: jrsmile/microcheck-sidecar:latest
      container_name: 'woodpecker-server-hc'
      restart: "always"
      healthcheck:
        test: ["CMD", "httpcheck", "http://localhost:8000"]
        interval: 30s
        timeout: 10s
        retries: 5
        start_period: 20s
      network_mode: "service:woodpecker-server"
      depends_on:
        woodpecker-server:
          condition: service_healthy
  woodpecker-agent:
    image: woodpeckerci/woodpecker-agent:v3
    container_name: woodpecker-agent
    hostname: 'woodpecker-agent'
    user: root
    command: agent
    restart: always
    depends_on:
      woodpecker-server-hc:
        condition: service_healthy
      woodpecker-server:
        condition: service_healthy
    volumes:
      - woodpecker-agent-config:/etc/woodpecker
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      - WOODPECKER_SERVER=172.30.0.21:9000
      - WOODPECKER_AGENT_SECRET=pssst
    networks:
      net1:
        ipv4_address: 172.30.0.22
  woodpecker-agent-hc:
    image: jrsmile/microcheck-sidecar:latest
    container_name: 'woodpecker-agent-hc'
    restart: "always"
    healthcheck:
      test: ["CMD", "portcheck", "--port", "3000"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 20s
    network_mode: "service:woodpecker-agent"
    depends_on:
      woodpecker-agent:
        condition: service_healthy
  gitea:
    image: docker.gitea.com/gitea:1.25.2
    container_name: gitea
    hostname: 'gitea'
    environment:
      - USER_UID=1000
      - USER_GID=1000
    restart: always
    volumes:
      - ./gitea:/data
      - /etc/timezone:/etc/timezone:ro
      - /etc/localtime:/etc/localtime:ro
    ports:
      #- "3100:3000"
      - "222:22"
    networks:
      net1:
        ipv4_address: 172.30.0.3
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.gitea.rule=Host(`gitea.docker.localhost`)"
      - "traefik.http.routers.gitea.entrypoints=websecure"
      - "traefik.http.services.gitea.loadbalancer.server.port=3000"
      - "traefik.http.routers.gitea.tls=true"
      - "traefik.http.routers.gitea.tls.certresolver=stepca"
    depends_on:
      traefik:
        condition: service_started
  gitea-hc:
      image: jrsmile/microcheck-sidecar:latest
      container_name: 'gitea-hc'
      restart: "always"
      healthcheck:
        test: ["CMD", "httpcheck", "http://localhost:3000"]
        interval: 30s
        timeout: 10s
        retries: 5
        start_period: 20s
      network_mode: "service:gitea"
      depends_on:
        gitea:
          condition: service_started
  semaphore:
    #ports:
    #  - 3010:3000
    image: semaphoreui/semaphore:v2.16.43
    container_name: semaphore
    hostname: 'semaphore'
    environment:
      SEMAPHORE_DB_DIALECT: sqlite
      SEMAPHORE_ADMIN: admin
      SEMAPHORE_ADMIN_PASSWORD: admin
      SEMAPHORE_ADMIN_NAME: admin
      SEMAPHORE_ADMIN_EMAIL: admin@localhost
      SEMAPHORE_USE_REMOTE_RUNNER: "True"
      SEMAPHORE_RUNNER_REGISTRATION_TOKEN: "fSsb/vPLW4kuPDdITgF2j+FndEGGGHPSEV3xcsmDK0U="
    volumes:
      - semaphore_data:/var/lib/semaphore
      - semaphore_config:/etc/semaphore
      - semaphore_tmp:/tmp/semaphore
    networks:
      net1:
        ipv4_address: 172.30.0.9
    depends_on:
      gitea:
        condition: service_started
      gitea-hc:
        condition: service_healthy
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.semaphore.rule=Host(`semaphore.docker.localhost`)"
      - "traefik.http.routers.semaphore.entrypoints=websecure"
      - "traefik.http.services.semaphore.loadbalancer.server.port=3000"
      - "traefik.http.routers.semaphore.tls=true"
      - "traefik.http.routers.semaphore.tls.certresolver=stepca"
  semaphore-hc:
    image: jrsmile/microcheck-sidecar:latest
    container_name: 'semaphore-hc'
    restart: "always"
    healthcheck:
      test: ["CMD", "httpcheck", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 20s
    network_mode: "service:semaphore"
    depends_on:
      semaphore:
        condition: service_started
  semaphore-runner:
    image: semaphoreui/runner:v2.16.43
    container_name: semaphore-runner
    hostname: 'semaphore-runner'
    environment:
      SEMAPHORE_RUNNER_PRIVATE_KEY_FILE: /var/lib/semaphore/runner.key
      SEMAPHORE_WEB_ROOT: http://semaphore:3000
      SEMAPHORE_RUNNER_REGISTRATION_TOKEN: fSsb/vPLW4kuPDdITgF2j+FndEGGGHPSEV3xcsmDK0U=
    networks:
      net1:
        ipv4_address: 172.30.0.10
    depends_on:
      semaphore-hc:
        condition: service_healthy
      semaphore:
        condition: service_started
  dex:
    image: dexidp/dex:latest
    container_name: dex
    hostname: 'dex'
    configs:
      - source: dex
        target: /etc/dex/config.yaml
    command: ["dex", "serve", "/etc/dex/config.yaml"]
    networks:
      net1:
        ipv4_address: 172.30.0.11
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.dex.rule=Host(`dex.docker.localhost`)"
      - "traefik.http.routers.dex.entrypoints=websecure"
      - "traefik.http.services.dex.loadbalancer.server.port=5556"
      - "traefik.http.routers.dex.tls=true"
      - "traefik.http.routers.dex.tls.certresolver=stepca"
    depends_on:
      traefik:
        condition: service_started
  ca:
    image: 'smallstep/step-ca:latest'
    container_name: 'ca'
    hostname: 'ca'
    user: root
    restart: always
    networks:
      net1:
        ipv4_address: 172.30.0.12
    #ports:
    #  - 9000:9000
    dns:
      - '172.30.0.50'
    environment:
      - "DOCKER_STEPCA_INIT_NAME=Local CA"
      - "DOCKER_STEPCA_INIT_DNS_NAMES=ca,ca.docker.localhost"
      - "DOCKER_STEPCA_INIT_PROVISIONER_NAME=admin"
      - "DOCKER_STEPCA_INIT_PASSWORD=admin"
      - "DOCKER_STEPCA_INIT_SSH=true"
      - "DOCKER_STEPCA_INIT_ACME=true"
    volumes:
      - 'step:/home/step'
    healthcheck:
      test: ["CMD", "step", "ca", "health", "--ca-url", "https://ca:9000", "--root", "/home/step/certs/root_ca.crt"]
      interval: 10s
      timeout: 10s
      retries: 5
    depends_on:
      coredns:
        condition: service_started
      coredns-hc:
        condition: service_healthy
  coredns:
    image: coredns/coredns:latest
    container_name: coredns
    hostname: 'coredns'
    restart: always
    command: -conf /etc/coredns/Corefile -dns.port 53
    configs:
      - source: coredns
        target: /etc/coredns/Corefile
    networks:
      net1:
        ipv4_address: 172.30.0.50
  coredns-hc:
    image: jrsmile/microcheck-sidecar:latest
    container_name: 'coredns-hc'
    restart: always
    healthcheck:
      test: ["CMD", "httpcheck", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 20s
    network_mode: "service:coredns"
    depends_on:
      coredns:
        condition: service_started
  traefik:
    image: "traefik:latest"
    container_name: "traefik"
    restart: unless-stopped
    security_opt:
      - no-new-privileges:true
    networks:
      net1:
        ipv4_address: 172.30.0.13
    command:
      - --api=true
      - --api.dashboard=true
      - --log.level=INFO
      - --accesslog=true
      - --ping=true
      - --ping.entryPoint=ping
      - --entrypoints.ping.address=:8080
      - --providers.docker=true
      - --providers.docker.exposedbydefault=false
      - --providers.docker.network=company
      - --providers.docker.watch=true
      - --entryPoints.web.address=:80
      - --entryPoints.web.http.redirections.entrypoint.to=websecure
      - --entryPoints.web.http.redirections.entrypoint.scheme=https
      - --entryPoints.websecure.address=:443
      - --entryPoints.websecure.http.tls=true
      - --entryPoints.websecure.asDefault=true
      - --entryPoints.websecure.http.tls.certresolver=stepca
      - --certificatesresolvers.stepca.acme.tlschallenge=true
      - --certificatesresolvers.stepca.acme.email=admin@localhost
      - --certificatesresolvers.stepca.acme.caCertificates=/home/step/certs/root_ca.crt
      - --certificatesresolvers.stepca.acme.caServerName=ca
      - --certificatesresolvers.stepca.acme.storage=/stepca/acme.json
      - --certificatesresolvers.stepca.acme.caServer=https://ca:9000/acme/acme/directory
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      - "traefik-certs:/stepca"
      - "step:/home/step:ro"
    environment:
      - LEGO_CA_CERTIFICATES=/home/step/certs/root_ca.crt
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.api.entrypoints=websecure"
      - "traefik.http.routers.api.rule=Host(`traefik.docker.localhost`)"
      - "traefik.http.routers.api.service=api@internal"
      - "traefik.http.routers.api.tls=true"
      - "traefik.http.routers.api.tls.certresolver=stepca"

    healthcheck:
      test: ["CMD", "traefik", "healthcheck", "--ping"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 30s
    depends_on:
      ca:
        condition: service_healthy
      coredns:
        condition: service_started
      coredns-hc:
        condition: service_healthy
  dockpeek:
    image: dockpeek/dockpeek:latest
    container_name: dockpeek
    hostname: 'dockpeek'
    environment:
      - SECRET_KEY=your_secure_secret_key # Required: Set a secure secret key
      - USERNAME=admin # username
      - PASSWORD=admin # password
    # Server name for UI (optional, auto-detected from Docker API if not set)
    #  - DOCKER_HOST_NAME=
    #ports:
    #  - "3420:8000"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    restart: unless-stopped
    networks:
      net1:
        ipv4_address: 172.30.0.15
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.dockpeek.rule=Host(`dockpeek.docker.localhost`)"
      - "traefik.http.routers.dockpeek.entrypoints=websecure"
      - "traefik.http.services.dockpeek.loadbalancer.server.port=8000"
      - "traefik.http.routers.dockpeek.tls=true"
      - "traefik.http.routers.dockpeek.tls.certresolver=stepca"
      - com.dnsdock.ip_addr=172.30.0.13
    depends_on:
      traefik:
        condition: service_started
  prometheus:
    image: prom/prometheus
    container_name: prometheus
    hostname: 'prometheus'
    restart: unless-stopped
    #ports:
    #  - 9090:9090
    networks:
      net1:
        ipv4_address: 172.30.0.16
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.prometheus.rule=Host(`prometheus.docker.localhost`)"
      - "traefik.http.routers.prometheus.entrypoints=websecure"
      - "traefik.http.services.prometheus.loadbalancer.server.port=9090"
      - "traefik.http.routers.prometheus.tls=true"
      - "traefik.http.routers.prometheus.tls.certresolver=stepca"
    depends_on:
      traefik:
        condition: service_started
  grafana:
    image: grafana/grafana-enterprise
    container_name: grafana
    hostname: 'grafana'
    restart: unless-stopped
    #ports:
    #  - '3001:3000'
    networks:
      net1:
        ipv4_address: 172.30.0.17
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.grafana.rule=Host(`grafana.docker.localhost`)"
      - "traefik.http.routers.grafana.entrypoints=websecure"
      - "traefik.http.services.grafana.loadbalancer.server.port=3000"
      - "traefik.http.routers.grafana.tls=true"
      - "traefik.http.routers.grafana.tls.certresolver=stepca"
    depends_on:
      traefik:
        condition: service_started
  alpine:
    image: qemux/qemu
    container_name: alpine
    environment:
      BOOT: "alpine"
    devices:
      - /dev/kvm
      - /dev/net/tun
    cap_add:
      - NET_ADMIN
    #ports:
    #  - 8006:8006
    volumes:
      - ./qemu:/storage
    restart: always
    stop_grace_period: 2m
    networks:
      net1:
        ipv4_address: 172.30.0.18
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.alpine.rule=Host(`alpine.docker.localhost`)"
      - "traefik.http.routers.alpine.entrypoints=websecure"
      - "traefik.http.services.alpine.loadbalancer.server.port=8006"
      - "traefik.http.routers.alpine.tls=true"
      - "traefik.http.routers.alpine.tls.certresolver=stepca"
    depends_on:
      traefik:
        condition: service_started
  postgres:
    image: postgres:latest
    container_name: postgres
    hostname: postgres
    restart: always
    security_opt:
      - no-new-privileges:true
    pids_limit: 100
    #read_only: true
    tmpfs:
      - /tmp
      - /var/run/postgresql
    volumes:
      - ./postgres/:/var/lib/postgresql/
    environment:
      - POSTGRES_MULTIPLE_DATABASES=mattermost,mattermost# passbolt,passbolt# paperless,paperless# netbox,netbox# docmost,docmost# coder,coder# onlyoffice,onlyoffice
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_USER=postgres
      - POSTGRES_DB=postgres
      - TZ
    configs:
      - source: create-multiple-postgresql-databases
        target: /docker-entrypoint-initdb.d/create-multiple-postgresql-databases.sh
    healthcheck:
          test: ["CMD-SHELL", "pg_isready -U postgres -d postgres"]
          interval: 5s
          timeout: 5s
          retries: 5
    networks:
      net1:
        ipv4_address: 172.30.0.19
  mattermost:
    depends_on:
      postgres:
        condition: service_healthy
      traefik:
        condition: service_started
    image: mattermost/mattermost-team-edition:latest
    container_name: mattermost
    hostname: mattermost
    restart: always
    security_opt:
      - no-new-privileges:true
    pids_limit: 200
    read_only: false
    tmpfs:
      - /tmp
    volumes:
      - mattermost-config:/mattermost/config:rw
      - mattermost-data:/mattermost/data:rw
      - mattermost-logs:/mattermost/logs:rw
      - mattermost-plugins:/mattermost/plugins:rw
      - mattermost-client-plugins:/mattermost/client/plugins:rw
      - mattermost-bleve:/mattermost/bleve-indexes:rw
      # When you want to use SSO with GitLab, you have to add the cert pki chain of GitLab inside Alpine
      # to avoid Token request failed: certificate signed by unknown authority 
      # (link: https://github.com/mattermost/mattermost-server/issues/13059 and https://github.com/mattermost/docker/issues/34)
      # - ${GITLAB_PKI_CHAIN_PATH}:/etc/ssl/certs/pki_chain.pem:ro
    environment:
      - TZ
      # necessary Mattermost options/variables (see env.example)
      - MM_SQLSETTINGS_DRIVERNAME=postgres
      - MM_SQLSETTINGS_DATASOURCE=postgres://mattermost:postgres@postgres:5432/mattermost?sslmode=disable&connect_timeout=10
      # necessary for bleve
      - MM_BLEVESETTINGS_INDEXDIR
      # additional settings
      - MM_SERVICESETTINGS_SITEURL
    #ports:
    #  - 8065:8065
    networks:
      net1:
        ipv4_address: 172.30.0.20
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.mattermost.rule=Host(`mattermost.docker.localhost`)"
      - "traefik.http.routers.mattermost.entrypoints=websecure"
      - "traefik.http.services.mattermost.loadbalancer.server.port=8065"
      - "traefik.http.routers.mattermost.tls=true"
      - "traefik.http.routers.mattermost.tls.certresolver=stepca"
  headscale:
    image: docker.io/headscale/headscale:latest
    restart: unless-stopped
    container_name: headscale
    hostname: headscale
    ports:
      - "8081:8080"
      - "9091:9090"
    volumes:
      - headscale-config:/etc/headscale
      - headscale-lib:/var/lib/headscale
      - headscale-run:/var/run/headscale
    command: serve
    healthcheck:
        test: ["CMD", "headscale", "health"]
    networks:
      net1:
        ipv4_address: 172.30.0.23
  passbolt:
    image: passbolt/passbolt:latest-ce-non-root
    container_name: passbolt
    hostname: passbolt
    restart: unless-stopped
    environment:
      APP_FULL_BASE_URL: https://passbolt.docker.localhost
      DATASOURCES_DEFAULT_HOST: "postgres"
      DATASOURCES_DEFAULT_USERNAME: "passbolt"
      DATASOURCES_DEFAULT_PASSWORD: "P4ssb0lt"
      DATASOURCES_DEFAULT_DATABASE: "passbolt"
    volumes:
      - ./passbolt/gpg_volume:/etc/passbolt/gpg
      - ./passbolt/jwt_volume:/etc/passbolt/jwt
    command:
      [
        "/usr/bin/wait-for.sh",
        "-t",
        "0",
        "db:3306",
        "--",
        "/docker-entrypoint.sh",
      ]
    ports:
    - 8088:8080
    - 8443:4433
    networks:
      net1:
        ipv4_address: 172.30.0.24
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.passbolt.rule=Host(`passbolt.docker.localhost`)"
      - "traefik.http.routers.passbolt.entrypoints=websecure"
      - "traefik.http.services.passbolt.loadbalancer.server.port=8443"
      - "traefik.http.routers.passbolt.tls=true"
      - "traefik.http.routers.passbolt.tls.certresolver=stepca"
    depends_on:
      traefik:
        condition: service_started
      postgres:
        condition: service_healthy
  n8n:
    image: n8nio/n8n:latest
    container_name: n8n
    hostname: n8n
    user: root
    environment:
      - N8N_RUNNERS_ENABLED=true
      - N8N_RUNNERS_MODE=external
      - N8N_RUNNERS_BROKER_LISTEN_ADDRESS=0.0.0.0
      - N8N_RUNNERS_AUTH_TOKEN=your-secret-here
      - N8N_NATIVE_PYTHON_RUNNER=true
    #ports:
    #  - "5678:5678"
    volumes:
      - n8n_data:/home/node/.n8n
    networks:
      net1:
        ipv4_address: 172.30.0.25
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.n8n.rule=Host(`n8n.docker.localhost`)"
      - "traefik.http.routers.n8n.entrypoints=websecure"
      - "traefik.http.services.n8n.loadbalancer.server.port=5678"
      - "traefik.http.routers.n8n.tls=true"
      - "traefik.http.routers.n8n.tls.certresolver=stepca"
    depends_on:
      traefik:
        condition: service_started
  n8n-runner:
    image: n8nio/runners:latest
    container_name: n8n-runner
    hostname: n8n-runner
    environment:
      - N8N_RUNNERS_TASK_BROKER_URI=http://n8n:5679
      - N8N_RUNNERS_AUTH_TOKEN=your-secret-here
    depends_on:
      n8n:
        condition: service_started
    networks:
      net1:
        ipv4_address: 172.30.0.26
  rustdesk:
    container_name: rustdesk
    image: rustdesk/rustdesk-server:latest
    environment:
      - ALWAYS_USE_RELAY=Y
    command: hbbs
    volumes:
      - ./rustdesk/hbbs/data:/root
    network_mode: "host"
    depends_on:
      - rustdesk-relay
    restart: unless-stopped
  rustdesk-relay:
    container_name: rustdesk-relay
    image: rustdesk/rustdesk-server:latest
    command: hbbr
    volumes:
      - ./rustdesk/hbbr/data:/root
    network_mode: "host"
    restart: unless-stopped
  pless-redis:
    image: docker.io/valkey/valkey:8.1-alpine
    container_name: pless-redis
    hostname: pless-redis
    restart: unless-stopped
    volumes:
      - ./pless-redis/data:/data
    networks:
      net1:
        ipv4_address: 172.30.0.27
    healthcheck:
      test: '[ $$(valkey-cli --pass "redis" ping) = ''PONG'' ]'
      start_period: 5s
      timeout: 3s
      interval: 1s
      retries: 5
  paperless-ngx:
    image: ghcr.io/paperless-ngx/paperless-ngx:latest
    container_name: paperless-ngx
    hostname: paperless-ngx
    restart: unless-stopped
    user: root
    depends_on:
      postgres:
        condition: service_healthy
      pless-redis:
        condition: service_healthy
      gotenberg:
        condition: service_started
      tika:
        condition: service_started
      traefik:
        condition: service_started
    #ports:
    #  - "8100:8000"
    volumes:
      - paperless-data:/usr/src/paperless/data
      - paperless-media:/usr/src/paperless/media
      - ./export:/usr/src/paperless/export
      - ./consume:/usr/src/paperless/consume
    environment:
      PAPERLESS_REDIS: redis://pless-redis:6379
      PAPERLESS_DBHOST: postgres
      PAPERLESS_DBNAME: paperless
      PAPERLESS_DBUSER: paperless
      PAPERLESS_DBPASS: postgres
      PAPERLESS_TIKA_ENABLED: 1
      PAPERLESS_TIKA_GOTENBERG_ENDPOINT: http://gotenberg:3000
      PAPERLESS_TIKA_ENDPOINT: http://tika:9998
      PAPERLESS_URL: https://paperless.docker.localhost
    networks:
      net1:
        ipv4_address: 172.30.0.28
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.paperless.rule=Host(`paperless.docker.localhost`)"
      - "traefik.http.routers.paperless.entrypoints=websecure"
      - "traefik.http.services.paperless.loadbalancer.server.port=8000"
      - "traefik.http.routers.paperless.tls=true"
      - "traefik.http.routers.paperless.tls.certresolver=stepca"
  gotenberg:
    image: docker.io/gotenberg/gotenberg:8.25
    container_name: gotenberg
    hostname: gotenberg
    restart: unless-stopped
    command:
      - "gotenberg"
      - "--chromium-disable-javascript=true"
      - "--chromium-allow-list=file:///tmp/.*"
    networks:
      net1:
        ipv4_address: 172.30.0.29
  tika:
    image: docker.io/apache/tika:latest
    container_name: tika
    hostname: tika
    restart: unless-stopped
    networks:
      net1:
        ipv4_address: 172.30.0.30
  paperless-gpt:
    # Use one of these image sources:
    image: icereed/paperless-gpt:latest # Docker Hub
    container_name: paperless-gpt
    hostname: paperless-gpt
    # image: ghcr.io/icereed/paperless-gpt:latest  # GitHub Container Registry
    environment:
      PAPERLESS_BASE_URL: "http://paperless-ngx:8000"
      PAPERLESS_API_TOKEN: "your_paperless_api_token"
      PAPERLESS_PUBLIC_URL: "http://paperless.docker.localhost" # Optional
      MANUAL_TAG: "paperless-gpt" # Optional, default: paperless-gpt
      AUTO_TAG: "paperless-gpt-auto" # Optional, default: paperless-gpt-auto
      # LLM Configuration - Choose one:

      # Option 1: Standard OpenAI
      LLM_PROVIDER: "openai"
      LLM_MODEL: "gpt-4o"
      OPENAI_API_KEY: "your_openai_api_key"

      # Option 2: Mistral
      # LLM_PROVIDER: "mistral"
      # LLM_MODEL: "mistral-large-latest"
      # MISTRAL_API_KEY: "your_mistral_api_key"

      # Option 3: Azure OpenAI
      # LLM_PROVIDER: "openai"
      # LLM_MODEL: "your-deployment-name"
      # OPENAI_API_KEY: "your_azure_api_key"
      # OPENAI_API_TYPE: "azure"
      # OPENAI_BASE_URL: "https://your-resource.openai.azure.com"

      # Option 3: Ollama (Local)
      # LLM_PROVIDER: "ollama"
      # LLM_MODEL: "qwen3:8b"
      # OLLAMA_HOST: "http://host.docker.internal:11434"
      # OLLAMA_CONTEXT_LENGTH: "8192" # Sets Ollama NumCtx (context window)
      # TOKEN_LIMIT: 1000 # Recommended for smaller models

      # Optional LLM Settings
      # LLM_LANGUAGE: "English" # Optional, default: English

      # OCR Configuration - Choose one:
      # Option 1: LLM-based OCR
      OCR_PROVIDER: "llm" # Default OCR provider
      VISION_LLM_PROVIDER: "ollama" # openai or ollama
      VISION_LLM_MODEL: "minicpm-v" # minicpm-v (ollama) or gpt-4o (openai)
      OLLAMA_HOST: "http://ollama:11434" # If using Ollama

      # OCR Processing Mode
      OCR_PROCESS_MODE: "image" # Optional, default: image, other options: pdf, whole_pdf
      PDF_SKIP_EXISTING_OCR: "false" # Optional, skip OCR for PDFs with existing OCR

      # Option 2: Google Document AI
      # OCR_PROVIDER: 'google_docai'       # Use Google Document AI
      # GOOGLE_PROJECT_ID: 'your-project'  # Your GCP project ID
      # GOOGLE_LOCATION: 'us'              # Document AI region
      # GOOGLE_PROCESSOR_ID: 'processor-id' # Your processor ID
      # GOOGLE_APPLICATION_CREDENTIALS: '/app/credentials.json' # Path to service account key

      # Option 3: Azure Document Intelligence
      # OCR_PROVIDER: 'azure'              # Use Azure Document Intelligence
      # AZURE_DOCAI_ENDPOINT: 'your-endpoint' # Your Azure endpoint URL
      # AZURE_DOCAI_KEY: 'your-key'        # Your Azure API key
      # AZURE_DOCAI_MODEL_ID: 'prebuilt-read' # Optional, defaults to prebuilt-read
      # AZURE_DOCAI_TIMEOUT_SECONDS: '120'  # Optional, defaults to 120 seconds
      # AZURE_DOCAI_OUTPUT_CONTENT_FORMAT: 'text' # Optional, defaults to 'text', other valid option is 'markdown'
      # 'markdown' requires the 'prebuilt-layout' model

      # Enhanced OCR Features
      CREATE_LOCAL_HOCR: "false" # Optional, save hOCR files locally
      LOCAL_HOCR_PATH: "/app/hocr" # Optional, path for hOCR files
      CREATE_LOCAL_PDF: "false" # Optional, save enhanced PDFs locally
      LOCAL_PDF_PATH: "/app/pdf" # Optional, path for PDF files
      PDF_UPLOAD: "false" # Optional, upload enhanced PDFs to paperless-ngx
      PDF_REPLACE: "false" # Optional and DANGEROUS, delete original after upload
      PDF_COPY_METADATA: "true" # Optional, copy metadata from original document
      PDF_OCR_TAGGING: "true" # Optional, add tag to processed documents
      PDF_OCR_COMPLETE_TAG: "paperless-gpt-ocr-complete" # Optional, tag name

      # Option 4: Docling Server
      # OCR_PROVIDER: 'docling'              # Use a Docling server
      # DOCLING_URL: 'http://your-docling-server:port' # URL of your Docling instance
      # DOCLING_IMAGE_EXPORT_MODE: "placeholder" # Optional, defaults to "embedded"
      # DOCLING_OCR_PIPELINE: "standard" # Optional, defaults to "vlm"
      # DOCLING_OCR_ENGINE: "easyocr" # Optional, defaults to "easyocr" (only used when `DOCLING_OCR_PIPELINE is set to 'standard')


      AUTO_OCR_TAG: "paperless-gpt-ocr-auto" # Optional, default: paperless-gpt-ocr-auto
      OCR_LIMIT_PAGES: "5" # Optional, default: 5. Set to 0 for no limit.
      LOG_LEVEL: "info" # Optional: debug, warn, error
    volumes:
      - ./prompts:/app/prompts # Mount the prompts directory
      # For Google Document AI:
      - ${HOME}/.config/gcloud/application_default_credentials.json:/app/credentials.json
      # For local hOCR and PDF saving:
      - ./hocr:/app/hocr # Only if CREATE_LOCAL_HOCR is true
      - ./pdf:/app/pdf # Only if CREATE_LOCAL_PDF is true
    ports:
      - "8180:8080"
    depends_on:
      - paperless-ngx
      - ollama
    networks:
      net1:
        ipv4_address: 172.30.0.31
  ollama:
    image: docker.io/ollama/ollama:latest
    container_name: ollama
    hostname: ollama
    ports:
      - 7869:11434
    volumes:
      - .:/code
      - ./ollama/ollama:/root/.ollama
    #pull_policy: always
    tty: true
    restart: always
    environment:
      - OLLAMA_KEEP_ALIVE=24h
      - OLLAMA_HOST=0.0.0.0
    networks:
      net1:
        ipv4_address: 172.30.0.32
  it-tools:
    container_name: it-tools
    hostname: it-tools
    image: sharevb/it-tools:latest
    pull_policy: always
    restart: unless-stopped
    #ports:
    #  - 8181:8080
    networks:
      net1:
        ipv4_address: 172.30.0.33
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.ittools.rule=Host(`ittools.docker.localhost`)"
      - "traefik.http.routers.ittools.entrypoints=websecure"
      - "traefik.http.services.ittools.loadbalancer.server.port=8080"
      - "traefik.http.routers.ittools.tls=true"
      - "traefik.http.routers.ittools.tls.certresolver=stepca"
    depends_on:
      traefik:
        condition: service_started
  onlyoffice-documentserver:
    build:
      context: .
    image: onlyoffice/documentserver #[-de,-ee]
    container_name: onlyoffice-documentserver
    environment:
      - DB_TYPE=postgres
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_NAME=onlyoffice
      - DB_USER=onlyoffice
      - AMQP_URI=amqp://guest:guest@onlyoffice-rabbitmq
      # Uncomment strings below to enable the JSON Web Token validation.
      #- JWT_ENABLED=true
      #- JWT_SECRET=secret
      #- JWT_HEADER=Authorization
      #- JWT_IN_BODY=true
    #ports:
    #  - '4080:80'
    #  - '4443:443'
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/info/info.json"]
      interval: 30s
      retries: 5
      start_period: 60s
      timeout: 10s
    stdin_open: true
    restart: always
    stop_grace_period: 60s
    volumes:
       - onlyoffice-data:/var/www/onlyoffice/Data
       - onlyoffice-logs:/var/log/onlyoffice
       - onlyoffice-cache:/var/lib/onlyoffice/documentserver/App_Data/cache/files
       - onlyoffice-public:/var/www/onlyoffice/documentserver-example/public/files
       - onlyoffice-fonts:/usr/share/fonts
    networks:
      net1:
        ipv4_address: 172.30.0.34
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.onlyoffice.rule=Host(`onlyoffice.docker.localhost`)"
      - "traefik.http.routers.onlyoffice.entrypoints=websecure"
      - "traefik.http.services.onlyoffice.loadbalancer.server.port=443"
      - "traefik.http.routers.onlyoffice.tls=true"
      - "traefik.http.routers.onlyoffice.tls.certresolver=stepca"
    depends_on:
      traefik:
        condition: service_started
      onlyoffice-rabbitmq:
        condition: service_healthy
      postgres:
        condition: service_healthy
  onlyoffice-rabbitmq:
    container_name: onlyoffice-rabbitmq
    hostname: onlyoffice-rabbitmq
    image: rabbitmq:3
    restart: always
    expose:
      - '5672'
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "status"]
      interval: 10s
      retries: 3
      start_period: 10s
      timeout: 10s
    networks:
      net1:
        ipv4_address: 172.30.0.35
  netbox:
    image: lscr.io/linuxserver/netbox:latest
    container_name: netbox
    hostname: netbox
    user: root
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      redis-cache:
        condition: service_healthy
      traefik:
        condition: service_started
    environment:
      - PUID=0
      - PGID=0
      - TZ=Etc/UTC
      - SUPERUSER_EMAIL=admin@example.com
      - SUPERUSER_PASSWORD=admin
      - ALLOWED_HOST=
      - DB_NAME=netbox
      - DB_USER=netbox
      - DB_PASSWORD=postgres
      - DB_HOST=postgres
      - DB_PORT=5432
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=redis
      - REDIS_DB_TASK=
      - REDIS_DB_CACHE=
      - BASE_PATH="/"
      - REMOTE_AUTH_ENABLED= #optional
      - REMOTE_AUTH_BACKEND= #optional
      - REMOTE_AUTH_HEADER= #optional
      - REMOTE_AUTH_AUTO_CREATE_USER= #optional
      - REMOTE_AUTH_DEFAULT_GROUPS= #optional
      - REMOTE_AUTH_DEFAULT_PERMISSIONS= #optional
    volumes:
      - netbox-config:/etc/netbox/config
    #ports:
    #  - 8110:8000
    restart: unless-stopped
    networks:
      net1:
        ipv4_address: 172.30.0.36
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.netbox.rule=Host(`netbox.docker.localhost`)"
      - "traefik.http.routers.netbox.entrypoints=websecure"
      - "traefik.http.services.netbox.loadbalancer.server.port=8000"
      - "traefik.http.routers.netbox.tls=true"
      - "traefik.http.routers.netbox.tls.certresolver=stepca"
  netbox-hc:
    image: jrsmile/microcheck-sidecar:latest
    container_name: 'netbox-hc'
    restart: "always"
    healthcheck:
      test: ["CMD", "portcheck", "--port", "8000"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 20s
    network_mode: "service:netbox"
    depends_on:
      netbox:
        condition: service_started
  redis:
    image: docker.io/valkey/valkey:8.1-alpine
    container_name: redis
    hostname: redis
    command:
      - sh
      - -c # this is to evaluate the $REDIS_PASSWORD from the env
      - valkey-server --appendonly yes --requirepass redis ## $$ because of docker-compose
    healthcheck: &redis-healthcheck
      test: '[ $$(valkey-cli --pass "redis" ping) = ''PONG'' ]'
      start_period: 5s
      timeout: 3s
      interval: 1s
      retries: 5
    volumes:
      - netbox-redis-data:/data
    networks:
      net1:
        ipv4_address: 172.30.0.38
  redis-cache:
    image: docker.io/valkey/valkey:8.1-alpine
    container_name: redis-cache
    hostname: redis-cache
    command:
      - sh
      - -c # this is to evaluate the $REDIS_PASSWORD from the env
      - valkey-server --requirepass redis ## $$ because of docker-compose
    healthcheck: *redis-healthcheck
    volumes:
      - netbox-redis-cache-data:/data
    networks:
      net1:
        ipv4_address: 172.30.0.39
  webhook:
    command: '-verbose -hooks=/etc/webhook/hooks.json -hotreload'
    image: lwlook/webhook
    volumes:
        - '/var/run/docker.sock:/var/run/docker.sock'
        - './webhook/scripts:/opt/scripts'
        - './webhook/webhook:/etc/webhook'
    container_name: webhook
    #ports:
    #    - '19111:9000'
    networks:
      net1:
        ipv4_address: 172.30.0.42
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.webhook.rule=Host(`webhook.docker.localhost`)"
      - "traefik.http.routers.webhook.entrypoints=websecure"
      - "traefik.http.services.webhook.loadbalancer.server.port=9000"
      - "traefik.http.routers.webhook.tls=true"
      - "traefik.http.routers.webhook.tls.certresolver=stepca"
    depends_on:
      traefik:
        condition: service_started
  webhook-hc:
    image: jrsmile/microcheck-sidecar:latest
    container_name: 'webhook-hc'
    restart: "always"
    healthcheck:
      test: ["CMD", "portcheck", "--port", "9000"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 20s
    network_mode: "service:webhook"
    depends_on:
      webhook:
        condition: service_started
  neko:
    image: "ghcr.io/m1k1o/neko/firefox:latest"
    container_name: neko
    hostname: neko
    restart: "unless-stopped"
    shm_size: "4gb"
    ports:
      #- "8085:8080"
      - "52000-52100:52000-52100/udp"
    environment:
      NEKO_DESKTOP_SCREEN: 1280x720@30
      NEKO_MEMBER_MULTIUSER_USER_PASSWORD: neko
      NEKO_MEMBER_MULTIUSER_ADMIN_PASSWORD: admin
      NEKO_WEBRTC_EPR: 52000-52100
      NEKO_WEBRTC_ICELITE: 1
      NEKO_NAT1TO1: 127.0.0.1
    networks:
      net1:
        ipv4_address: 172.30.0.43
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.neko.rule=Host(`neko.docker.localhost`)"
      - "traefik.http.routers.neko.entrypoints=websecure"
      - "traefik.http.services.neko.loadbalancer.server.port=8080"
      - "traefik.http.routers.neko.tls=true"
      - "traefik.http.routers.neko.tls.certresolver=stepca"
    depends_on:
      traefik:
        condition: service_started
  wetty:
    command: '--base=/ --ssh-host=172.30.0.1'
    image: wettyoss/wetty
    container_name: wetty
    hostname: wetty
    #ports:
    #    - '1234:3000'
    networks:
      net1:
        ipv4_address: 172.30.0.44
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.wetty.rule=Host(`wetty.docker.localhost`)"
      - "traefik.http.routers.wetty.entrypoints=websecure"
      - "traefik.http.services.wetty.loadbalancer.server.port=3000"
      - "traefik.http.routers.wetty.tls=true"
      - "traefik.http.routers.wetty.tls.certresolver=stepca"
    depends_on:
      traefik:
        condition: service_started
  wetty-hc:
    image: jrsmile/microcheck-sidecar:latest
    container_name: 'wetty-hc'
    restart: "always"
    healthcheck:
      test: ["CMD", "portcheck", "--port", "3000"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 20s
    network_mode: "service:wetty"
    depends_on:
      wetty:
        condition: service_started
  coder:
    # This MUST be stable for our documentation and
    # other automations.
    image: ghcr.io/coder/coder:latest
    container_name: coder
    user: root
    hostname: coder
    #ports:
    #  - "7080:7080"
    environment:
      CODER_PG_CONNECTION_URL: "postgresql://coder:postgres@postgres/coder?sslmode=disable"
      CODER_HTTP_ADDRESS: "0.0.0.0:7080"
      # You'll need to set CODER_ACCESS_URL to an IP or domain
      # that workspaces can reach. This cannot be localhost
      # or 127.0.0.1 for non-Docker templates!
      CODER_ACCESS_URL: "http://coder:7080"
    # If the coder user does not have write permissions on
    # the docker socket, you can uncomment the following
    # lines and set the group ID to one that has write
    # permissions on the docker socket.
    #group_add:
    #  - "998" # docker group on host
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      # Run "docker volume rm coder_coder_home" to reset the dev tunnel url (https://abc.xyz.try.coder.app).
      # This volume is not required in a production environment - you may safely remove it.
      # Coder can recreate all the files it needs on restart.
      - coder_home:/home/coder
    depends_on:
      postgres:
        condition: service_healthy
      traefik:
        condition: service_started
    networks:
      net1:
        ipv4_address: 172.30.0.45
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.coder.rule=Host(`coder.docker.localhost`)"
      - "traefik.http.routers.coder.entrypoints=websecure"
      - "traefik.http.services.coder.loadbalancer.server.port=7080"
      - "traefik.http.routers.coder.tls=true"
      - "traefik.http.routers.coder.tls.certresolver=stepca"
  coder-hc:
    image: jrsmile/microcheck-sidecar:latest
    container_name: 'coder-hc'
    restart: "always"
    healthcheck:
      test: ["CMD", "httpcheck", "http://localhost:7080"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 20s
    network_mode: "service:coder"
    depends_on:
      coder:
        condition: service_started
  docmost:
    image: docmost/docmost:latest
    container_name: docmost
    hostname: docmost
    depends_on:
      postgres:
        condition: service_healthy
      doc-redis:
        condition: service_healthy
      traefik:
        condition: service_started
    environment:
      APP_URL: "http://localhost:3000"
      APP_SECRET: "3fc0dd9af11abb9f2585049f8990b588"
      DATABASE_URL: "postgresql://docmost:postgres@postgres:5432/docmost?schema=public"
      REDIS_URL: "redis://doc-redis:6379"
    #ports:
    #  - "3000:3000"
    restart: unless-stopped
    volumes:
      - docmost:/app/data/storage
    networks:
      net1:
        ipv4_address: 172.30.0.40
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.docmost.rule=Host(`docmost.docker.localhost`)"
      - "traefik.http.routers.docmost.entrypoints=websecure"
      - "traefik.http.services.docmost.loadbalancer.server.port=3000"
      - "traefik.http.routers.docmost.tls=true"
      - "traefik.http.routers.docmost.tls.certresolver=stepca"
  doc-redis:
    image: docker.io/valkey/valkey:8.1-alpine
    container_name: doc-redis
    hostname: doc-redis
    restart: unless-stopped
    volumes:
      - doc-redis_data:/data
    networks:
      net1:
        ipv4_address: 172.30.0.46
    healthcheck:
      test: '[ $$(valkey-cli --pass "redis" ping) = ''PONG'' ]'
      start_period: 5s
      timeout: 3s
      interval: 1s
      retries: 5
  docmost-hc:
      image: jrsmile/microcheck-sidecar:latest
      container_name: 'docmost-hc'
      restart: "always"
      healthcheck:
        test: ["CMD", "httpcheck", "http://localhost:3000"]
        interval: 30s
        timeout: 10s
        retries: 5
        start_period: 20s
      network_mode: "service:docmost"
      depends_on:
        docmost:
          condition: service_started
  opencloud:
    image: opencloudeu/opencloud-rolling:latest
    # changelog: https://github.com/opencloud-eu/opencloud/tree/main/changelog
    # release notes: https://docs.opencloud.eu/opencloud_release_notes.html
    user: root
    container_name: opencloud
    networks:
      net1:
        ipv4_address: 172.30.0.47
    entrypoint:
      - /bin/sh
    # run opencloud init to initialize a configuration file with random secrets
    # it will fail on subsequent runs, because the config file already exists
    # therefore we ignore the error and then start the opencloud server
    command: ["-c", "opencloud init || true; opencloud server"]
    environment:
      # enable services that are not started automatically
      OC_ADD_RUN_SERVICES: true
      OC_URL: https://opencloud.docker.localhost
      OC_LOG_LEVEL: "info"
      OC_LOG_COLOR: "false"
      OC_LOG_PRETTY: "false"
      # do not use SSL between the reverse proxy and OpenCloud
      PROXY_TLS: "false"
      # INSECURE: needed if OpenCloud / reverse proxy is using self generated certificates
      OC_INSECURE: "true"
      # basic auth (not recommended, but needed for eg. WebDav clients that do not support OpenID Connect)
      PROXY_ENABLE_BASIC_AUTH: "${PROXY_ENABLE_BASIC_AUTH:-false}"
      # demo users
      IDM_CREATE_DEMO_USERS: "false"
      # admin password
      IDM_ADMIN_PASSWORD: "admin"
      # email server (if configured)
      NOTIFICATIONS_SMTP_HOST: "mailserver"
      NOTIFICATIONS_SMTP_PORT: "25"
      NOTIFICATIONS_SMTP_SENDER: "OpenCloud Notifications <notifications@cloud.opencloud.test>"
      NOTIFICATIONS_SMTP_USERNAME: ""
      NOTIFICATIONS_SMTP_PASSWORD: ""
      NOTIFICATIONS_SMTP_INSECURE: "true"
      NOTIFICATIONS_SMTP_AUTHENTICATION: ""
      NOTIFICATIONS_SMTP_ENCRYPTION: "none"
      FRONTEND_ARCHIVER_MAX_SIZE: "10000000000"
      FRONTEND_CHECK_FOR_UPDATES: "false"
      # PROXY_CSP_CONFIG_FILE_LOCATION: /etc/opencloud/csp.yaml
      # enable to allow using the banned passwords list
      # OC_PASSWORD_POLICY_BANNED_PASSWORDS_LIST: banned-password-list.txt
      # control the password enforcement and policy for public shares
      OC_SHARING_PUBLIC_SHARE_MUST_HAVE_PASSWORD: "${OC_SHARING_PUBLIC_SHARE_MUST_HAVE_PASSWORD:-true}"
      OC_SHARING_PUBLIC_WRITEABLE_SHARE_MUST_HAVE_PASSWORD: "${OC_SHARING_PUBLIC_WRITEABLE_SHARE_MUST_HAVE_PASSWORD:-true}"
      OC_PASSWORD_POLICY_DISABLED: "${OC_PASSWORD_POLICY_DISABLED:-false}"
      OC_PASSWORD_POLICY_MIN_CHARACTERS: "${OC_PASSWORD_POLICY_MIN_CHARACTERS:-8}"
      OC_PASSWORD_POLICY_MIN_LOWERCASE_CHARACTERS: "${OC_PASSWORD_POLICY_MIN_LOWERCASE_CHARACTERS:-1}"
      OC_PASSWORD_POLICY_MIN_UPPERCASE_CHARACTERS: "${OC_PASSWORD_POLICY_MIN_UPPERCASE_CHARACTERS:-1}"
      OC_PASSWORD_POLICY_MIN_DIGITS: "${OC_PASSWORD_POLICY_MIN_DIGITS:-1}"
      OC_PASSWORD_POLICY_MIN_SPECIAL_CHARACTERS: "${OC_PASSWORD_POLICY_MIN_SPECIAL_CHARACTERS:-1}"
    volumes:
      - opencloud-config:/etc/opencloud
      - opencloud-data:/var/lib/opencloud
      - opencloud-apps:/var/lib/opencloud/web/assets/apps
    logging:
      driver: local
    restart: always
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.opencloud.rule=Host(`opencloud.docker.localhost`)"
      - "traefik.http.routers.opencloud.entrypoints=web"
      - "traefik.http.services.opencloud.loadbalancer.server.port=8080"
    depends_on:
      traefik:
        condition: service_started
  rustfs:
    image: 'rustfs/rustfs:latest'
    user: root
    environment:
        - RUSTFS_SERVER_DOMAINS=internal.docker
        - RUSTFS_CONSOLE_ENABLE=true
        - RUSTFS_SECRET_KEY=rustfsadmin
        - RUSTFS_ACCESS_KEY=rustfsadmin
    volumes:
        - 'rustfs-data:/data'
    ports:
        # - '9001:9001'
        - '9002:9000'
    container_name: rustfs
    networks:
      net1:
        ipv4_address: 172.30.0.48
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.rustfs.rule=Host(`rustfs.docker.localhost`)"
      - "traefik.http.routers.rustfs.entrypoints=websecure"
      - "traefik.http.services.rustfs.loadbalancer.server.port=9001"
      - "traefik.http.routers.rustfs.tls=true"
      - "traefik.http.routers.rustfs.tls.certresolver=stepca"
    depends_on:
      traefik:
        condition: service_started
  rustfs-hc:
    image: jrsmile/microcheck-sidecar:latest
    container_name: 'rustfs-hc'
    restart: "always"
    healthcheck:
      test: ["CMD", "portcheck", "--port","9001"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 20s
    network_mode: "service:rustfs"
    depends_on:
      rustfs:
        condition: service_started

  mailserver:
    image: ghcr.io/docker-mailserver/docker-mailserver:latest
    container_name: mailserver
    # Provide the FQDN of your mail server here (Your DNS MX record should point to this value)
    hostname: mailserver.docker.localhost
    ports:
      - "25:25"
      - "465:465"
      - "587:587"
      - "993:993"
    volumes:
      - mail-data:/var/mail/
      - mail-state:/var/mail-state/
      - mail-logs:/var/log/mail/
      - mail-config:/tmp/docker-mailserver/
      - /etc/localtime:/etc/localtime:ro
    environment:
      - ENABLE_RSPAMD=1
      - ENABLE_CLAMAV=1
      - ENABLE_FAIL2BAN=0
    restart: always
    networks:
      net1:
        ipv4_address: 172.30.0.52

  arcane:
    image: ghcr.io/getarcaneapp/arcane:latest
    container_name: arcane
    restart: unless-stopped
    #ports:
    #  - 3552:3552
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - arcane-data:/app/data
    environment:
      - APP_URL=https://arcane.docker.localhost
      - PUID=1000
      - PGID=1000
      - ENCRYPTION_KEY=880d5998162f7f469e4515e02af1bd97bfe612fdbc70cfd4856f9084ff1d0f83
      - JWT_SECRET=733637cfc9d54b90879b35acbd61687851833ea2ac37030d821bf3b8306ceeff
      - LOG_LEVEL=info
      - LOG_JSON=false
      - OIDC_ENABLED=false
      - DATABASE_URL=file:data/arcane.db?_pragma=journal_mode(WAL)&_pragma=busy_timeout(2500)&_txlock=immediate
    networks:
      net1:
        ipv4_address: 172.30.0.51
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.arcane.rule=Host(`arcane.docker.localhost`)"
      - "traefik.http.routers.arcane.entrypoints=websecure"
      - "traefik.http.services.arcane.loadbalancer.server.port=3552"
      - "traefik.http.routers.arcane.tls=true"
      - "traefik.http.routers.arcane.tls.certresolver=stepca"
  post-install:
    command: 'chroot /host /bin/bash -c "echo Done || exit 0"'
    image: busybox
    container_name: 'post-install'
    hostname: 'post-install'
    volumes:
        - '/:/host'
    ipc: host
    pid: host
    network_mode: "host"
    privileged: true
    tty: true
    restart: "no"
    depends_on:
      rustfs:
        condition: service_started
        restart: false
      rustfs-hc:
        condition: service_healthy
      traefik:
        condition: service_started

networks:
  net1:
    name: company
    ipam:
      driver: default
      config:
        - subnet: 172.30.0.0/16
          gateway: 172.30.0.1

volumes:
  arcane-data:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/arcane/data"
        map: "1000/1000:@1000/@1000"
  headscale-config:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/headscale/config"
        map: "1000/0:@1000/@0"
  headscale-lib:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/headscale/lib"
        map: "1000/0:@1000/@0"
  headscale-run:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/headscale/run"
        map: "1000/0:@1000/@0"
  mail-data:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/mailserver/data"
        map: "1000/0:@1000/@0"
  mail-state:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/mailserver/state"
        map: "1000/0:@1000/@0"
  mail-logs:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/mailserver/logs"
        map: "1000/0:@1000/@0"
  mail-config:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/mailserver/config"
        map: "1000/0:@1000/@0"
  lldap_data:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/lldap/data"
        map: "1000/1000:@1000/@1000"
  traefik-certs:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/traefik/certs"
        map: "1000/0:@1000/@0"
  docmost:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/docmost/data"
        map: "1000/0:@1000/@0"
  doc-redis_data:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/docmost/redis"
        map: "1000/0:@1000/@0"
  rustfs-data:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/rustfs/data"
        map: "1000/0:@1000/@0"
  semaphore_data:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/semaphore/data"
        map: "1000/0:@1000/@0"
  semaphore_config:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/semaphore/config"
        map: "1000/0:@1000/@0"
  semaphore_tmp:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/semaphore/tmp"
        map: "1000/0:@1000/@0"
  dockge:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/dockge"
        map: "1000/0:@1000/@0"
  step:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/step"
        map: "1000/0:@1000/@0"
  woodpecker-server-data:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/woodpecker/data"
        map: "1000/0:@1000/@0"
  woodpecker-agent-config:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/woodpecker/agentconfig"
        map: "1000/0:@1000/@0"
  paperless-data:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/paperless/data"
        map: "1000/1000:@1000/@1000"
  paperless-media:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/paperless/media"
        map: "1000/1000:@1000/@1000"
  n8n_data:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/n8n/data"
        map: "1000/0:@1000/@0"
  netbox-config:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/netbox/config"
        map: "1000/0:@1000/@0"
  netbox-postgres-data:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/netbox/postgresdata"
        map: "1000/0:@1000/@0"
  netbox-redis-cache-data:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/netbox/redis-cache/data"
        map: "1000/0:@1000/@0"
  netbox-redis-data:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/netbox/redis/data"
        map: "1000/0:@1000/@0"
  netbox-reports-files:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/netbox/reports"
        map: "1000/0:@1000/@0"
  netbox-scripts-files:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/netbox/scripts"
        map: "1000/0:@1000/@0"
  coder_home:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/coder"
        map: "1000/0:@1000/@0"
  data:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/data"
        map: "1000/0:@1000/@0"
  mattermost-config:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/mattermost/config"
        map: "1000/2000:@1000/@2000"
  mattermost-data:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/mattermost/data"
        map: "1000/2000:@1000/@2000"
  mattermost-logs:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/mattermost/logs"
        map: "1000/2000:@1000/@2000"
  mattermost-plugins:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/mattermost/plugins"
        map: "1000/2000:@1000/@2000"
  mattermost-client-plugins:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/mattermost/client-plugins"
        map: "1000/2000:@1000/@2000"
  mattermost-bleve:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/mattermost/bleve"
        map: "1000/2000:@1000/@2000"
  opencloud-config:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/opencloud/config"
        map: "1000/0:@1000/@0"
  opencloud-data:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/opencloud/data"
        map: "1000/0:@1000/@0"
  opencloud-apps:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/opencloud/apps"
        map: "1000/0:@1000/@0"
  onlyoffice-data:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/onlyoffice/data"
        map: "1000/0:@1000/@0"
  onlyoffice-logs:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/onlyoffice/logs"
        map: "1000/0:@1000/@0"
  onlyoffice-cache:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/onlyoffice/cache"
        map: "1000/0:@1000/@0"
  onlyoffice-public:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/onlyoffice/public"
        map: "1000/0:@1000/@0"
  onlyoffice-fonts:
    driver: ghcr.io/studioetrange/bindfs:latest
    driver_opts:
        sourcePath: "${PWD}/onlyoffice/fonts"
        map: "1000/0:@1000/@0"

configs:
  coredns:
    content: |
      .:53 {
          health :8080
          errors
          log
          template IN A docker.localhost {
              answer "{{ .Name }} 60 IN A 172.30.0.13"
          }
          forward . 8.8.8.8 1.1.1.1
      }
  dex:
    content: |
      issuer: http://dex.docker.localhost/dex
      storage:
        type: memory
      web:
        http: 0.0.0.0:5556
      staticClients:
        - id: example-app
          redirectURIs:
            - 'http://localhost:5555/callback'
          name: 'Example App'
          secret: ZXhhbXBsZS1hcHAtc2VjcmV0
      enablePasswordDB: true
      staticPasswords:
        - email: "admin@example.com"
          hash: "$2a$10$2b2cU8CPhOTaGrs1HRQuAueS7JTT5ZHsHSzYiFPm1leZck7Mc8T4W"
          username: "admin"
          userID: "1234"
  create-multiple-postgresql-databases:
    content: |
      #!/bin/bash

      set -e
      set -u

      function create_user_and_database() {
        local database=$$(echo $$1 | tr ',' ' ' | awk  '{print $$1}')
        local owner=$$(echo $$1 | tr ',' ' ' | awk  '{print $$2}')
        echo "  Creating user and database '$$database'"
        psql -v ON_ERROR_STOP=1 --username "$$POSTGRES_USER" <<-EOSQL
            CREATE USER $$owner;
            ALTER USER $$owner WITH PASSWORD '$$POSTGRES_PASSWORD';
            CREATE DATABASE $$database;
            GRANT ALL PRIVILEGES ON DATABASE $$database TO $$owner;
            ALTER DATABASE $$database OWNER TO $$owner;
      EOSQL
      }

      if [ -n "$$POSTGRES_MULTIPLE_DATABASES" ]; then
        echo "Multiple database creation requested: $$POSTGRES_MULTIPLE_DATABASES"
        for db in $$(echo $$POSTGRES_MULTIPLE_DATABASES | tr '#' ' '); do
          create_user_and_database $$db
        done
        echo "Multiple databases created"
      fi